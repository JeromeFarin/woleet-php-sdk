<?php
/**
 * AuthorizedSignee
 *
 * PHP version 5
 *
 * @category Class
 * @package  WooletClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 * Woleet API
 *
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation.
 *
 * OpenAPI spec version: 1.10.0
 * Contact: contact@woleet.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.27
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace WooletClient\Model;

use \ArrayAccess;
use \WooletClient\ObjectSerializer;

/**
 * AuthorizedSignee Class Doc Comment
 *
 * @category Class
 * @package  WooletClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AuthorizedSignee implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
     * The original name of the model.
     *
     * @var string
     */
    protected static $swaggerModelName = 'authorizedSignee';

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @var string[]
     */
    protected static $swaggerTypes = [
        'common_name' => 'string',
        'email' => 'string',
        'country_calling_code' => 'string',
        'phone' => 'string',
        'requires_otp' => 'bool',
        'signs_face_to_face' => 'bool',
        'vars' => 'object',
        'lang' => 'string',
        'pub_key' => 'string',
        'device' => 'string',
        'identity_url' => 'string',
        'feedback_subject' => 'string',
        'feedback_message' => 'string',
        'anchor_id' => 'string',
        'signed_on' => 'int',
        'audit_trail_id' => 'string',
        'id' => 'string',
        'otp' => 'string'];

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @var string[]
     */
    protected static $swaggerFormats = [
        'common_name' => null,
        'email' => null,
        'country_calling_code' => null,
        'phone' => null,
        'requires_otp' => null,
        'signs_face_to_face' => null,
        'vars' => null,
        'lang' => null,
        'pub_key' => null,
        'device' => null,
        'identity_url' => null,
        'feedback_subject' => null,
        'feedback_message' => null,
        'anchor_id' => null,
        'signed_on' => 'int64',
        'audit_trail_id' => null,
        'id' => null,
        'otp' => null];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'common_name' => 'commonName',
        'email' => 'email',
        'country_calling_code' => 'countryCallingCode',
        'phone' => 'phone',
        'requires_otp' => 'requiresOTP',
        'signs_face_to_face' => 'signsFaceToFace',
        'vars' => 'vars',
        'lang' => 'lang',
        'pub_key' => 'pubKey',
        'device' => 'device',
        'identity_url' => 'identityURL',
        'feedback_subject' => 'feedbackSubject',
        'feedback_message' => 'feedbackMessage',
        'anchor_id' => 'anchorId',
        'signed_on' => 'signedOn',
        'audit_trail_id' => 'auditTrailId',
        'id' => 'id',
        'otp' => 'OTP'];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'common_name' => 'setCommonName',
        'email' => 'setEmail',
        'country_calling_code' => 'setCountryCallingCode',
        'phone' => 'setPhone',
        'requires_otp' => 'setRequiresOtp',
        'signs_face_to_face' => 'setSignsFaceToFace',
        'vars' => 'setVars',
        'lang' => 'setLang',
        'pub_key' => 'setPubKey',
        'device' => 'setDevice',
        'identity_url' => 'setIdentityUrl',
        'feedback_subject' => 'setFeedbackSubject',
        'feedback_message' => 'setFeedbackMessage',
        'anchor_id' => 'setAnchorId',
        'signed_on' => 'setSignedOn',
        'audit_trail_id' => 'setAuditTrailId',
        'id' => 'setId',
        'otp' => 'setOtp'];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'common_name' => 'getCommonName',
        'email' => 'getEmail',
        'country_calling_code' => 'getCountryCallingCode',
        'phone' => 'getPhone',
        'requires_otp' => 'getRequiresOtp',
        'signs_face_to_face' => 'getSignsFaceToFace',
        'vars' => 'getVars',
        'lang' => 'getLang',
        'pub_key' => 'getPubKey',
        'device' => 'getDevice',
        'identity_url' => 'getIdentityUrl',
        'feedback_subject' => 'getFeedbackSubject',
        'feedback_message' => 'getFeedbackMessage',
        'anchor_id' => 'getAnchorId',
        'signed_on' => 'getSignedOn',
        'audit_trail_id' => 'getAuditTrailId',
        'id' => 'getId',
        'otp' => 'getOtp'];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const DEVICE_SERVER = 'SERVER';
    const DEVICE_MOBILE = 'MOBILE';
    const DEVICE_NANO = 'NANO';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDeviceAllowableValues()
    {
        return [
            self::DEVICE_SERVER,
            self::DEVICE_MOBILE,
            self::DEVICE_NANO,];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['common_name'] = isset($data['common_name']) ? $data['common_name'] : null;
        $this->container['email'] = isset($data['email']) ? $data['email'] : null;
        $this->container['country_calling_code'] = isset($data['country_calling_code']) ? $data['country_calling_code'] : null;
        $this->container['phone'] = isset($data['phone']) ? $data['phone'] : null;
        $this->container['requires_otp'] = isset($data['requires_otp']) ? $data['requires_otp'] : null;
        $this->container['signs_face_to_face'] = isset($data['signs_face_to_face']) ? $data['signs_face_to_face'] : null;
        $this->container['vars'] = isset($data['vars']) ? $data['vars'] : null;
        $this->container['lang'] = isset($data['lang']) ? $data['lang'] : null;
        $this->container['pub_key'] = isset($data['pub_key']) ? $data['pub_key'] : null;
        $this->container['device'] = isset($data['device']) ? $data['device'] : null;
        $this->container['identity_url'] = isset($data['identity_url']) ? $data['identity_url'] : null;
        $this->container['feedback_subject'] = isset($data['feedback_subject']) ? $data['feedback_subject'] : null;
        $this->container['feedback_message'] = isset($data['feedback_message']) ? $data['feedback_message'] : null;
        $this->container['anchor_id'] = isset($data['anchor_id']) ? $data['anchor_id'] : null;
        $this->container['signed_on'] = isset($data['signed_on']) ? $data['signed_on'] : null;
        $this->container['audit_trail_id'] = isset($data['audit_trail_id']) ? $data['audit_trail_id'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['otp'] = isset($data['otp']) ? $data['otp'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];
        $allowedValues = $this->getDeviceAllowableValues();
        if (!is_null($this->container['device']) && !in_array($this->container['device'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'device', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets common_name
     *
     * @return string
     */
    public function getCommonName()
    {
        return $this->container['common_name'];
    }

    /**
     * Sets common_name
     *
     * @param string $common_name The full name of the signer.
     *
     * @return $this
     */
    public function setCommonName($common_name)
    {
        $this->container['common_name'] = $common_name;
        return $this;
    }

    /**
     * Gets email
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->container['email'];
    }

    /**
     * Sets email
     *
     * @param string $email The email of the signer.<br> Two signers cannot have the same email.<br> If set, `commonName` must also be set.
     *
     * @return $this
     */
    public function setEmail($email)
    {
        $this->container['email'] = $email;
        return $this;
    }

    /**
     * Gets country_calling_code
     *
     * @return string
     */
    public function getCountryCallingCode()
    {
        return $this->container['country_calling_code'];
    }

    /**
     * Sets country_calling_code
     *
     * @param string $country_calling_code The country calling code of the signer (numbers only, no white space).
     *
     * @return $this
     */
    public function setCountryCallingCode($country_calling_code)
    {
        $this->container['country_calling_code'] = $country_calling_code;
        return $this;
    }

    /**
     * Gets phone
     *
     * @return string
     */
    public function getPhone()
    {
        return $this->container['phone'];
    }

    /**
     * Sets phone
     *
     * @param string $phone The phone number of the signer (not including the country calling code, numbers only, no white spaces).<br> Two signers cannot have the same phone number.<br> If set, `commonName` must also be set.<br> This phone number must support SMS delivery.
     *
     * @return $this
     */
    public function setPhone($phone)
    {
        $this->container['phone'] = $phone;
        return $this;
    }

    /**
     * Gets requires_otp
     *
     * @return bool
     */
    public function getRequiresOtp()
    {
        return $this->container['requires_otp'];
    }

    /**
     * Sets requires_otp
     *
     * @param bool $requires_otp `true` if the signer must provide an OTP to sign.<br> If `true`, `phone` must be set, since the OTP is sent by SMS.
     *
     * @return $this
     */
    public function setRequiresOtp($requires_otp)
    {
        $this->container['requires_otp'] = $requires_otp;
        return $this;
    }

    /**
     * Gets signs_face_to_face
     *
     * @return bool
     */
    public function getSignsFaceToFace()
    {
        return $this->container['signs_face_to_face'];
    }

    /**
     * Sets signs_face_to_face
     *
     * @param bool $signs_face_to_face `true` if the signer must sign face-to-face, or `false` (or unset) if the signer must sign using the regular signature workflow.<br> If `true`, `requiresOTP` must also be `true`.
     *
     * @return $this
     */
    public function setSignsFaceToFace($signs_face_to_face)
    {
        $this->container['signs_face_to_face'] = $signs_face_to_face;
        return $this;
    }

    /**
     * Gets vars
     *
     * @return object
     */
    public function getVars()
    {
        return $this->container['vars'];
    }

    /**
     * Sets vars
     *
     * @param object $vars A set of variables (key/value pairs) that can be used to customize the signature request workflow for this signer.<br> Values must be of type null, boolean, string or number: nested JSON objects are not allowed.<br> Variables defined here overwrites the ones defined at signature request level when emailing the signer.<br> **This property is only available to the owner and the signers of the signature request.**
     *
     * @return $this
     */
    public function setVars($vars)
    {
        $this->container['vars'] = $vars;
        return $this;
    }

    /**
     * Gets lang
     *
     * @return string
     */
    public function getLang()
    {
        return $this->container['lang'];
    }

    /**
     * Sets lang
     *
     * @param string $lang The preferred language (provided as an ISO 639-1 string) to use when emailing the signer.<br> If set, this property overwrites the `lang` property defined at signature request level.
     *
     * @return $this
     */
    public function setLang($lang)
    {
        $this->container['lang'] = $lang;
        return $this;
    }

    /**
     * Gets pub_key
     *
     * @return string
     */
    public function getPubKey()
    {
        return $this->container['pub_key'];
    }

    /**
     * Sets pub_key
     *
     * @param string $pub_key The public key the signer must use to sign.<br> If not set, the signer can use any key to sign.<br> **Currently only Bitcoin addresses are supported.**
     *
     * @return $this
     */
    public function setPubKey($pub_key)
    {
        $this->container['pub_key'] = $pub_key;
        return $this;
    }

    /**
     * Gets device
     *
     * @return string
     */
    public function getDevice()
    {
        return $this->container['device'];
    }

    /**
     * Sets device
     *
     * @param string $device The type of device the signer should use to sign:<br> - SERVER: Woleet.ID Server or equivalent<br> - MOBILE: Woleet.ID Mobile or equivalent<br> - NANO: Ledger Nano S or equivalent<br> If set, the signature application can use it to propose only the corresponding signature mode.
     *
     * @return $this
     */
    public function setDevice($device)
    {
        $allowedValues = $this->getDeviceAllowableValues();
        if (!is_null($device) && !in_array($device, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'device', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['device'] = $device;
        return $this;
    }

    /**
     * Gets identity_url
     *
     * @return string
     */
    public function getIdentityUrl()
    {
        return $this->container['identity_url'];
    }

    /**
     * Sets identity_url
     *
     * @param string $identity_url Web hook to use to verify the signer's identity.<br> If set, this property overwrites the `identityURL` property defined at signature request level.
     *
     * @return $this
     */
    public function setIdentityUrl($identity_url)
    {
        $this->container['identity_url'] = $identity_url;
        return $this;
    }

    /**
     * Gets feedback_subject
     *
     * @return string
     */
    public function getFeedbackSubject()
    {
        return $this->container['feedback_subject'];
    }

    /**
     * Sets feedback_subject
     *
     * @param string $feedback_subject Last feedback subject reported by the signer to the owner of the signature request.<br> **This property is only available to the owner of the signature request.**
     *
     * @return $this
     */
    public function setFeedbackSubject($feedback_subject)
    {
        $this->container['feedback_subject'] = $feedback_subject;
        return $this;
    }

    /**
     * Gets feedback_message
     *
     * @return string
     */
    public function getFeedbackMessage()
    {
        return $this->container['feedback_message'];
    }

    /**
     * Sets feedback_message
     *
     * @param string $feedback_message Last feedback message reported by the signer to the owner of the signature request.<br> **This property is only available to the owner of the signature request.**
     *
     * @return $this
     */
    public function setFeedbackMessage($feedback_message)
    {
        $this->container['feedback_message'] = $feedback_message;
        return $this;
    }

    /**
     * Gets anchor_id
     *
     * @return string
     */
    public function getAnchorId()
    {
        return $this->container['anchor_id'];
    }

    /**
     * Sets anchor_id
     *
     * @param string $anchor_id If the signer has signed, identifier of the signature anchor created.
     *
     * @return $this
     */
    public function setAnchorId($anchor_id)
    {
        $this->container['anchor_id'] = $anchor_id;
        return $this;
    }

    /**
     * Gets signed_on
     *
     * @return int
     */
    public function getSignedOn()
    {
        return $this->container['signed_on'];
    }

    /**
     * Sets signed_on
     *
     * @param int $signed_on If the signer has signed, date of signature (in milliseconds since Unix epoch).
     *
     * @return $this
     */
    public function setSignedOn($signed_on)
    {
        $this->container['signed_on'] = $signed_on;
        return $this;
    }

    /**
     * Gets audit_trail_id
     *
     * @return string
     */
    public function getAuditTrailId()
    {
        return $this->container['audit_trail_id'];
    }

    /**
     * Sets audit_trail_id
     *
     * @param string $audit_trail_id Identifier of the signer in the audit trail.
     *
     * @return $this
     */
    public function setAuditTrailId($audit_trail_id)
    {
        $this->container['audit_trail_id'] = $audit_trail_id;
        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id **WARNING: Do not use (test purpose only).**
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;
        return $this;
    }

    /**
     * Gets otp
     *
     * @return string
     */
    public function getOtp()
    {
        return $this->container['otp'];
    }

    /**
     * Sets otp
     *
     * @param string $otp **WARNING: Do not use (test purpose only).**
     *
     * @return $this
     */
    public function setOtp($otp)
    {
        $this->container['otp'] = $otp;
        return $this;
    }

    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed $value Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
