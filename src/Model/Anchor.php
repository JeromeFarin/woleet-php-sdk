<?php
/**
 * Anchor
 *
 * PHP version 5
 *
 * @category Class
 * @package  WooletClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 * Woleet API
 *
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation.
 *
 * OpenAPI spec version: 1.10.0
 * Contact: contact@woleet.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.27
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace WooletClient\Model;

use \ArrayAccess;
use \WooletClient\ObjectSerializer;

/**
 * Anchor Class Doc Comment
 *
 * @category Class
 * @package  WooletClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Anchor implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
     * The original name of the model.
     *
     * @var string
     */
    protected static $swaggerModelName = 'anchor';

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @var string[]
     */
    protected static $swaggerTypes = [
        'id' => 'string',
        'created' => 'int',
        'last_modified' => 'int',
        'name' => 'string',
        'hash' => 'string',
        'signed_hash' => 'string',
        'signed_identity' => 'string',
        'signed_issuer_domain' => 'string',
        'pub_key' => 'string',
        'signature' => 'string',
        'identity_url' => 'string',
        'public' => 'bool',
        'notify_by_email' => 'bool',
        'tags' => 'string[]',
        'metadata' => 'object',
        'callback_url' => 'string',
        'status' => 'string',
        'timestamp' => 'int',
        'confirmations' => 'int',
        'tx_id' => 'string'];

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @var string[]
     */
    protected static $swaggerFormats = [
        'id' => null,
        'created' => 'int64',
        'last_modified' => 'int64',
        'name' => null,
        'hash' => null,
        'signed_hash' => null,
        'signed_identity' => null,
        'signed_issuer_domain' => null,
        'pub_key' => null,
        'signature' => null,
        'identity_url' => null,
        'public' => null,
        'notify_by_email' => null,
        'tags' => null,
        'metadata' => null,
        'callback_url' => null,
        'status' => null,
        'timestamp' => 'int64',
        'confirmations' => 'int32',
        'tx_id' => null];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'created' => 'created',
        'last_modified' => 'lastModified',
        'name' => 'name',
        'hash' => 'hash',
        'signed_hash' => 'signedHash',
        'signed_identity' => 'signedIdentity',
        'signed_issuer_domain' => 'signedIssuerDomain',
        'pub_key' => 'pubKey',
        'signature' => 'signature',
        'identity_url' => 'identityURL',
        'public' => 'public',
        'notify_by_email' => 'notifyByEmail',
        'tags' => 'tags',
        'metadata' => 'metadata',
        'callback_url' => 'callbackURL',
        'status' => 'status',
        'timestamp' => 'timestamp',
        'confirmations' => 'confirmations',
        'tx_id' => 'txId'];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'created' => 'setCreated',
        'last_modified' => 'setLastModified',
        'name' => 'setName',
        'hash' => 'setHash',
        'signed_hash' => 'setSignedHash',
        'signed_identity' => 'setSignedIdentity',
        'signed_issuer_domain' => 'setSignedIssuerDomain',
        'pub_key' => 'setPubKey',
        'signature' => 'setSignature',
        'identity_url' => 'setIdentityUrl',
        'public' => 'setPublic',
        'notify_by_email' => 'setNotifyByEmail',
        'tags' => 'setTags',
        'metadata' => 'setMetadata',
        'callback_url' => 'setCallbackUrl',
        'status' => 'setStatus',
        'timestamp' => 'setTimestamp',
        'confirmations' => 'setConfirmations',
        'tx_id' => 'setTxId'];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'created' => 'getCreated',
        'last_modified' => 'getLastModified',
        'name' => 'getName',
        'hash' => 'getHash',
        'signed_hash' => 'getSignedHash',
        'signed_identity' => 'getSignedIdentity',
        'signed_issuer_domain' => 'getSignedIssuerDomain',
        'pub_key' => 'getPubKey',
        'signature' => 'getSignature',
        'identity_url' => 'getIdentityUrl',
        'public' => 'getPublic',
        'notify_by_email' => 'getNotifyByEmail',
        'tags' => 'getTags',
        'metadata' => 'getMetadata',
        'callback_url' => 'getCallbackUrl',
        'status' => 'getStatus',
        'timestamp' => 'getTimestamp',
        'confirmations' => 'getConfirmations',
        'tx_id' => 'getTxId'];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATUS_WAIT = 'WAIT';
    const STATUS__NEW = 'NEW';
    const STATUS_SENT = 'SENT';
    const STATUS_CONFIRMED = 'CONFIRMED';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_WAIT,
            self::STATUS__NEW,
            self::STATUS_SENT,
            self::STATUS_CONFIRMED,];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['created'] = isset($data['created']) ? $data['created'] : null;
        $this->container['last_modified'] = isset($data['last_modified']) ? $data['last_modified'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['hash'] = isset($data['hash']) ? $data['hash'] : null;
        $this->container['signed_hash'] = isset($data['signed_hash']) ? $data['signed_hash'] : null;
        $this->container['signed_identity'] = isset($data['signed_identity']) ? $data['signed_identity'] : null;
        $this->container['signed_issuer_domain'] = isset($data['signed_issuer_domain']) ? $data['signed_issuer_domain'] : null;
        $this->container['pub_key'] = isset($data['pub_key']) ? $data['pub_key'] : null;
        $this->container['signature'] = isset($data['signature']) ? $data['signature'] : null;
        $this->container['identity_url'] = isset($data['identity_url']) ? $data['identity_url'] : null;
        $this->container['public'] = isset($data['public']) ? $data['public'] : null;
        $this->container['notify_by_email'] = isset($data['notify_by_email']) ? $data['notify_by_email'] : null;
        $this->container['tags'] = isset($data['tags']) ? $data['tags'] : null;
        $this->container['metadata'] = isset($data['metadata']) ? $data['metadata'] : null;
        $this->container['callback_url'] = isset($data['callback_url']) ? $data['callback_url'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['timestamp'] = isset($data['timestamp']) ? $data['timestamp'] : null;
        $this->container['confirmations'] = isset($data['confirmations']) ? $data['confirmations'] : null;
        $this->container['tx_id'] = isset($data['tx_id']) ? $data['tx_id'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];
        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id Anchor identifier. It is allocated by the platform, and so must not be provided at creation time.
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;
        return $this;
    }

    /**
     * Gets created
     *
     * @return int
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param int $created Date of creation (in milliseconds since Unix epoch).
     *
     * @return $this
     */
    public function setCreated($created)
    {
        $this->container['created'] = $created;
        return $this;
    }

    /**
     * Gets last_modified
     *
     * @return int
     */
    public function getLastModified()
    {
        return $this->container['last_modified'];
    }

    /**
     * Sets last_modified
     *
     * @param int $last_modified Date of last modification (in milliseconds since Unix epoch).
     *
     * @return $this
     */
    public function setLastModified($last_modified)
    {
        $this->container['last_modified'] = $last_modified;
        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Name of the anchor (doesn't need to be unique).
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;
        return $this;
    }

    /**
     * Gets hash
     *
     * @return string
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param string $hash SHA256 hash (ie. the fingerprint) of the data to anchor.<br> The value must be provided as an hexadecimal lowercase string. The hash of the empty file is forbidden.<br> **This property must not be provided when creating a signature anchor: it is automatically set at creation time to the SHA256 hash of the `signature` property provided, meaning that the signature is the actual anchored data.**
     *
     * @return $this
     */
    public function setHash($hash)
    {
        $this->container['hash'] = $hash;
        return $this;
    }

    /**
     * Gets signed_hash
     *
     * @return string
     */
    public function getSignedHash()
    {
        return $this->container['signed_hash'];
    }

    /**
     * Sets signed_hash
     *
     * @param string $signed_hash SHA256 hash (ie. the fingerprint) of the signed data.<br> The value must be provided as an hexadecimal lowercase string. The hash of the empty file is forbidden.<br> **This property must not be provided when creating a data anchor.**
     *
     * @return $this
     */
    public function setSignedHash($signed_hash)
    {
        $this->container['signed_hash'] = $signed_hash;
        return $this;
    }

    /**
     * Gets signed_identity
     *
     * @return string
     */
    public function getSignedIdentity()
    {
        return $this->container['signed_identity'];
    }

    /**
     * Sets signed_identity
     *
     * @param string $signed_identity X500 Distinguished Name representing the signed identity.<br> **This property must not be provided when creating a data anchor.**
     *
     * @return $this
     */
    public function setSignedIdentity($signed_identity)
    {
        $this->container['signed_identity'] = $signed_identity;
        return $this;
    }

    /**
     * Gets signed_issuer_domain
     *
     * @return string
     */
    public function getSignedIssuerDomain()
    {
        return $this->container['signed_issuer_domain'];
    }

    /**
     * Sets signed_issuer_domain
     *
     * @param string $signed_issuer_domain Domain name of the identity issuer (ie. of the organization who verified the identity).<br> If set, the domain name of the identity URL must be included in the `signedIssuerDomain` domain name.<br> **This property must not be provided when creating a data anchor.**
     *
     * @return $this
     */
    public function setSignedIssuerDomain($signed_issuer_domain)
    {
        $this->container['signed_issuer_domain'] = $signed_issuer_domain;
        return $this;
    }

    /**
     * Gets pub_key
     *
     * @return string
     */
    public function getPubKey()
    {
        return $this->container['pub_key'];
    }

    /**
     * Sets pub_key
     *
     * @param string $pub_key Public key of the signer.<br> **Currently only Bitcoin addresses are supported.**<br> **This property must not be provided when creating a data anchor.**
     *
     * @return $this
     */
    public function setPubKey($pub_key)
    {
        $this->container['pub_key'] = $pub_key;
        return $this;
    }

    /**
     * Gets signature
     *
     * @return string
     */
    public function getSignature()
    {
        return $this->container['signature'];
    }

    /**
     * Sets signature
     *
     * @param string $signature Signature of the `signedHash` property using the public key `pubKey`, or, if any of the `signedIdentity` or `signedIssuerDomain` properties are provided, signature of SHA256(`signedHash` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.<br> **Only Bitcoin signatures are currently supported.**<br> **This property must not be provided when creating a data anchor.**
     *
     * @return $this
     */
    public function setSignature($signature)
    {
        $this->container['signature'] = $signature;
        return $this;
    }

    /**
     * Gets identity_url
     *
     * @return string
     */
    public function getIdentityUrl()
    {
        return $this->container['identity_url'];
    }

    /**
     * Sets identity_url
     *
     * @param string $identity_url Web hook of the identity server to use to verify the signer's identity.<br> This URL allows to retrieve the identity associated to the public key `pubKey`. It can also be used to verify that the identity server (itself identified by the TLS certificate of the URL) controls the key used to sign (ie. owns the private part of the key pair) by requesting it to sign some random data.<br> This URL MUST use an HTTPS scheme with a valid and non expired TLS certificate.<br> This URL MUST implement the following GET operation:<br> Query parameters:<br> - `pubKey`: the public key to be verified - mandatory<br> - `leftData`: the left part of the data to be signed (generated randomly by the caller) - if set, the identity server MAY provide a `signature`<br> Output:<br> A JSON object with: - `rightData`: the right part of the data signed (generated randomly by the identity server) - optional<br> - `signature`: the signature of the string `leftData` + `rightData` using the public key `pubKey` - optional<br> - `identity`: the X500 identity associated to the key claimed by the identity server - optional<br> - `key`: additional information about the key - optional<br> If `identity` is not provided, `signature` and `rightData` MUST be provided: in such a case the identity of the signer can be extracted from the TLS certificate.
     *
     * @return $this
     */
    public function setIdentityUrl($identity_url)
    {
        $this->container['identity_url'] = $identity_url;
        return $this;
    }

    /**
     * Gets public
     *
     * @return bool
     */
    public function getPublic()
    {
        return $this->container['public'];
    }

    /**
     * Sets public
     *
     * @param bool $public `true` (or unset) if the anchor is public (ie. discoverable by its `hash` or `signedHash`) or `false` if it must be private (ie. not discoverable).
     *
     * @return $this
     */
    public function setPublic($public)
    {
        $this->container['public'] = $public;
        return $this;
    }

    /**
     * Gets notify_by_email
     *
     * @return bool
     */
    public function getNotifyByEmail()
    {
        return $this->container['notify_by_email'];
    }

    /**
     * Sets notify_by_email
     *
     * @param bool $notify_by_email `true` if the proof receipt must be sent by email once available, or `false` (or unset) if not.
     *
     * @return $this
     */
    public function setNotifyByEmail($notify_by_email)
    {
        $this->container['notify_by_email'] = $notify_by_email;
        return $this;
    }

    /**
     * Gets tags
     *
     * @return string[]
     */
    public function getTags()
    {
        return $this->container['tags'];
    }

    /**
     * Sets tags
     *
     * @param string[] $tags Set of tags associated to the anchor. There is no restriction on tag names, except they cannot contain spaces.<br> Tags are aimed at classifying and searching anchors.
     *
     * @return $this
     */
    public function setTags($tags)
    {
        $this->container['tags'] = $tags;
        return $this;
    }

    /**
     * Gets metadata
     *
     * @return object
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param object $metadata A set of variables (key/values pairs) to store with the anchor.<br> Values must be of type null, boolean, string or number: nested JSON objects are not allowed.
     *
     * @return $this
     */
    public function setMetadata($metadata)
    {
        $this->container['metadata'] = $metadata;
        return $this;
    }

    /**
     * Gets callback_url
     *
     * @return string
     */
    public function getCallbackUrl()
    {
        return $this->container['callback_url'];
    }

    /**
     * Sets callback_url
     *
     * @param string $callback_url Web hook to be called by the platform whenever the `status` property of the anchor changes:<br> the platform does a POST request on this URL with the anchor as a JSON object in the request body.<br> Verifying the authenticity of the callback can be done by checking the HMAC-SHA1 signature of the request body provided by the platform in the `x-woleet-signature` header.<br> Please refer to the <a target=\"_blank\" href=\"https://doc.woleet.io/reference#using-callbacks\">documentation</a> for more details.
     *
     * @return $this
     */
    public function setCallbackUrl($callback_url)
    {
        $this->container['callback_url'] = $callback_url;
        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status Status of the anchor:<br> - WAIT: waiting to be processed by the platform (the proof receipt is not yet available for download)<br> - NEW: waiting to be sent to the blockchain (the proof receipt is not yet available for download)<br> - SENT: sent to the blockchain (the proof receipt is ready to download)<br> - CONFIRMED: confirmed at least 6 times by the blockchain (the proof receipt can be verified)
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;
        return $this;
    }

    /**
     * Gets timestamp
     *
     * @return int
     */
    public function getTimestamp()
    {
        return $this->container['timestamp'];
    }

    /**
     * Sets timestamp
     *
     * @param int $timestamp Proven timestamp of the data (for a data anchor) or of the signature (for a signature anchor).<br> This is actually the time of the Bitcoin block into which the anchoring process occurred (in milliseconds since Unix epoch).<br> Any data whose SHA256 hash equals this anchor's hash is proven to exist at that time and has not been modified since.<br> This property is set when the first confirmation of the Bitcoin block occurs. Once set, the associated proof receipt can be verified (without having to wait for 6 confirmations).
     *
     * @return $this
     */
    public function setTimestamp($timestamp)
    {
        $this->container['timestamp'] = $timestamp;
        return $this;
    }

    /**
     * Gets confirmations
     *
     * @return int
     */
    public function getConfirmations()
    {
        return $this->container['confirmations'];
    }

    /**
     * Sets confirmations
     *
     * @param int $confirmations Number of confirmations of the Bitcoin block into which the anchoring process occurred.<br> This property is set when the first confirmation of the Bitcoin block occurs, and removed once the block is confirmed at least 6 times.
     *
     * @return $this
     */
    public function setConfirmations($confirmations)
    {
        $this->container['confirmations'] = $confirmations;
        return $this;
    }

    /**
     * Gets tx_id
     *
     * @return string
     */
    public function getTxId()
    {
        return $this->container['tx_id'];
    }

    /**
     * Sets tx_id
     *
     * @param string $tx_id Identifier of the Bitcoin transaction where the anchoring occurred.
     *
     * @return $this
     */
    public function setTxId($tx_id)
    {
        $this->container['tx_id'] = $tx_id;
        return $this;
    }

    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed $value Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
